substitutions:
  devicename: hub
  comment: ""
  light_address_1: "{0x00,0x00,0x00,0x00,0x00,0x00}"
  light_address_2: "{0x00,0x00,0x00,0x00,0x00,0x00}"

esphome:
  name: $devicename
  comment: $comment
  platform: ESP8266
  board: d1_mini
  includes:
  - lib/MeshRC.h
  - lib/esp_now_light.h

wifi:
  networks:
  reboot_timeout: 300s

logger:

api:
  services:
    - service: restart_node
      then:
        - switch.turn_on: restartswitch

ota:
  password: $devicename !secret otapass

web_server:

switch:
  - platform: restart
    id: restartswitch

power_supply:
  - id: 'power_supply1'
    enable_time: 2s
    keep_on_time: 10s
    pin: 
      number: GPIO4
      inverted: true

light:
- platform: custom
  lambda: |-
    uint8_t light_address_1[6] = ${light_address_1};
    uint8_t light_address_2[6] = ${light_address_2};
    auto light_out_1 = new esp_now_light_RGB(light_address_1,1);
    auto light_out_2 = new esp_now_light_RGB(light_address_2,1);
    light_out_1->set_power_supply(id(power_supply1));
    light_out_2->set_power_supply(id(power_supply1));
    App.register_component(light_out_1);
    App.register_component(light_out_2);
    return {light_out_1, light_out_2};
  lights:
    - name: "Custom Light 1"
      effects:
      - automation:
          name: "Addressable 1 (Rainbow)"
          sequence:
            lambda: ;
      - automation:
          name: "Addressable 2 (Color Wipe)"
          sequence:
            lambda: ;
      - automation:
          name: "Addressable 3 (Scan)"
          sequence:
            lambda: ;
      - automation:
          name: "Addressable 4 (Twinkle)"
          sequence:
            lambda: ;
      - automation:
          name: "Addressable 5 (Random Twinkle)"
          sequence:
            lambda: ;
      - automation:
          name: "Addressable 6 (Fireworks)"
          sequence:
            lambda: ;
      - automation:
          name: "Addressable 7 (Random Fireworks)"
          sequence:
            lambda: ;
      - automation:
          name: "Fade"
          sequence:
            lambda: ;
      - automation:
          name: "Strobe"
          sequence:
            lambda: ;
      - automation:
          name: "Strobe (RGB)"
          sequence:
            lambda: ;
    - name: "Custom Light 2"
      effects:
      - automation:
          name: "Addressable 1 (Rainbow)"
          sequence:
            lambda: ;
      - automation:
          name: "Addressable 2 (Color Wipe)"
          sequence:
            lambda: ;
      - automation:
          name: "Addressable 3 (Scan)"
          sequence:
            lambda: ;
      - automation:
          name: "Addressable 4 (Twinkle)"
          sequence:
            lambda: ;
      - automation:
          name: "Addressable 5 (Random Twinkle)"
          sequence:
            lambda: ;
      - automation:
          name: "Addressable 6 (Fireworks)"
          sequence:
            lambda: ;
      - automation:
          name: "Addressable 7 (Random Fireworks)"
          sequence:
            lambda: ;
      - automation:
          name: "Fade"
          sequence:
            lambda: ;
      - automation:
          name: "Strobe"
          sequence:
            lambda: ;
      - automation:
          name: "Strobe (RGB)"
          sequence:
            lambda: ;

sensor:
  - platform: wifi_signal
    name: ${devicename} WiFi Signal Sensor
    unit_of_measurement: "%"
    filters:
    - lambda: |-
        if(x <= -100){
          return  0;
        } else if (x >= -50) {
          return 100;
        } else {
          return 2 * (x + 100);
        }

script:
  - id: light_status_script_1
    mode: restart
    then:
      - binary_sensor.template.publish:
          id: status_1
          state: ON
      - delay: 30s
      - binary_sensor.template.publish:
          id: status_1
          state: OFF
  - id: light_status_script_2
    mode: restart
    then:
      - binary_sensor.template.publish:
          id: status_2
          state: ON
      - delay: 30s
      - binary_sensor.template.publish:
          id: status_2
          state: OFF
          
binary_sensor:
  - platform: template
    name: "${devicename} Light 1 Status"
    id: status_1
    device_class: connectivity
  - platform: template
    name: "${devicename} Light 2 Status"
    id: status_2
    device_class: connectivity
    
custom_component:
- lambda: |-
    
    MeshRC::begin();

    ESP_LOGD("custom", "Initialising MeshRC");
    
    MeshRC::on("", [](uint8_t* data, uint8_t size) {
      // Process an incomming message, if it is directed to us, then we handle it.
      ESP_LOGD("custom", "Receiving any MeshRC message");
      
      uint8_t dest_1[6] = ${light_address_1};
      uint8_t dest_2[6] = ${light_address_2};
      if (size > 6 && MeshRC::equals(data, dest_1, 6) && (data[6] == '<')) {
      // Message on the communication channel with light_address_1
          uint8_t* newData = &data[5];
          ESP_LOGD("custom", "Receiving meshRC message");
          newData[0] = '1';
          MeshRC::recvHandler(MeshRC::sender, newData, size - 5);
      }
      else if (size > 6 && MeshRC::equals(data, dest_2, 6) && (data[6] == '<')) {
      // Message on the communication channel with light_address_2
          uint8_t* newData = &data[5];
          ESP_LOGD("custom", "Receiving meshRC message");
          newData[0] = '2';
          MeshRC::recvHandler(MeshRC::sender, newData, size - 5);
      }
    });
    
    
    MeshRC::on("1<PING", [](uint8_t* data, uint8_t size) {
      ESP_LOGD("custom", "Receiving meshRC message PING on 1");
      id(light_status_script_2).execute();
    });
    
    MeshRC::on("2<PING", [](uint8_t* data, uint8_t size) {
      ESP_LOGD("custom", "Receiving meshRC message PING on 2");
      id(light_status_script_2).execute();
    });
    return {};
